 Implement a Stack using `std::vector`

A `std::vector` is a perfect choice for implementing a stack. Its `push_back()`, `pop_back()`, `back()`, and `empty()` methods map directly to the required stack operations. We will wrap this functionality in a class to enforce the stack's LIFO rules.

```cpp
#include <iostream>
#include <vector>
#include <stdexcept> // For std::out_of_range

using namespace std;

// A Stack implementation using std::vector as the underlying container
class ArrayStack {
private:
    vector<int> data;

public:
    // Pushes an element onto the top of the stack.
    void push(int value) {
        data.push_back(value);
        cout << "Pushed " << value << " onto the stack." << endl;
    }

    // Removes the top element from the stack.
    void pop() {
        if (isEmpty()) {
            cout << "Stack is empty. Cannot pop." << endl;
            return;
        }
        cout << "Popped " << data.back() << " from the stack." << endl;
        data.pop_back();
    }

    // Returns the top element of the stack without removing it.
    int top() {
        if (isEmpty()) {
            // It's better to throw an exception than to return a magic number
            throw out_of_range("Stack is empty. Cannot peek.");
        }
        return data.back();
    }

    // Checks if the stack is empty.
    bool isEmpty() {
        return data.empty();
    }
};

int main() {
    ArrayStack myStack;

    myStack.push(10);
    myStack.push(20);
    myStack.push(30);

    cout << "Top element is: " << myStack.top() << endl; // Should be 30

    myStack.pop(); // Pops 30
    cout << "Top element is: " << myStack.top() << endl; // Should be 20

    myStack.pop(); // Pops 20
    myStack.pop(); // Pops 10

    if (myStack.isEmpty()) {
        cout << "The stack is now empty." << endl;
    }

    // This will now cause an error because the stack is empty
    myStack.pop(); 

    return 0;
}
```

-----
