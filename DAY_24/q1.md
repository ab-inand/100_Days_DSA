
-------
Here we have a complete program demonstrating both insertion methods. Pay close attention to the function signatures, especially `Node*& head`, which means we are passing the `head` pointer **by reference** so we can modify it directly.

```cpp
#include <iostream>

using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

void printList(Node* head) {
    Node* current = head;
    cout << "List: ";
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "nullptr" << endl;
}

/**
 * Inserts a new node at the beginning of the list.
 * @param head A reference to the head pointer of the list.
 * We use a reference so we can change what 'head' points to.
 * @param data The data for the new node.
 */
void push_front(Node*& head, int data) {
    // 1. Create the new node
    Node* newNode = new Node(data);
    // 2. Set its 'next' to the current head
    newNode->next = head;
    // 3. Update the head to be the new node
    head = newNode;
}

/**
 * Inserts a new node at the end of the list.
 * @param head A reference to the head pointer of the list.
 */
void append(Node*& head, int data) {
    // 1. Create the new node
    Node* newNode = new Node(data);

    // 2. Handle the edge case of an empty list
    if (head == nullptr) {
        head = newNode;
        return;
    }

    // 3. Find the last node
    Node* current = head;
    while (current->next != nullptr) {
        current = current->next;
    }

    // 4. Link the last node to the new node
    current->next = newNode;
}

void cleanup(Node*& head) {
    Node* current = head;
    while(current != nullptr) {
        Node* nodeToDelete = current;
        current = current->next;
        delete nodeToDelete;
    }
    head = nullptr;
}


int main() {
    Node* head = nullptr; // Start with an empty list

    cout << "Appending 10 to the list..." << endl;
    append(head, 10);
    printList(head);

    cout << "Appending 20..." << endl;
    append(head, 20);
    printList(head);

    cout << "Pushing 5 to the front..." << endl;
    push_front(head, 5);
    printList(head);

    // Clean up all allocated memory
    cleanup(head);
    cout << "Cleaned up memory." << endl;
    
    return 0;
}
```

-----
