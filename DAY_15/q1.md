
#### \#\# Medium: Find the k-th Smallest Element (QuickSelect)

This implementation uses the same `partition` function from Quick Sort but replaces the `quickSort` logic with the `quickSelect` logic.

```cpp
#include <iostream>
#include <vector>
#include <utility> // For std::swap

using namespace std;

// Using the same Lomuto partition function from Day 14
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

// Function to find the k-th smallest element
int quickSelect(vector<int>& arr, int low, int high, int k) {
    // k is 1-based, so we are looking for index k-1
    if (k > 0 && k <= high - low + 1) {
        // Partition the array and get the pivot's final index
        int pivot_index = partition(arr, low, high);

        // If pivot is the k-th element, we found it
        if (pivot_index - low == k - 1) {
            return arr[pivot_index];
        }

        // If k-th element is in the left subarray
        if (pivot_index - low > k - 1) {
            return quickSelect(arr, low, pivot_index - 1, k);
        }

        // Otherwise, it's in the right subarray
        return quickSelect(arr, pivot_index + 1, high, k - (pivot_index - low + 1));
    }

    // k is out of bounds
    return -1; // Or throw an exception
}

int main() {
    vector<int> numbers = {10, 4, 5, 8, 6, 11, 26};
    int k = 3; // Find the 3rd smallest element

    // The 3rd smallest element should be 6
    // Sorted array would be: {4, 5, 6, 8, 10, 11, 26}

    cout << "The " << k << "-rd smallest element is: "
         << quickSelect(numbers, 0, numbers.size() - 1, k) << endl;

    return 0;
}
```

-----
