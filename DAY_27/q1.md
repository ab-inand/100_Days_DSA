
#### \#\# Medium: Implement a Doubly Linked List with Insertion at the Head

For a structure like this, it's good practice to create a class to manage the `head` and `tail` pointers and encapsulate the operations.

```cpp
#include <iostream>

using namespace std;

// Node for a doubly linked list
struct Node {
    int data;
    Node* next;
    Node* prev;

    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    // Destructor to clean up memory
    ~DoublyLinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* nodeToDelete = current;
            current = current->next;
            delete nodeToDelete;
        }
    }

    // --- Implementation Task: Insertion at the head ---
    void push_front(int data) {
        Node* newNode = new Node(data);

        // If the list is empty
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
            return;
        }

        // If the list is not empty
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }

    void printList() {
        Node* current = head;
        cout << "List (forward):  nullptr <-> ";
        while (current != nullptr) {
            cout << current->data << " <-> ";
            current = current->next;
        }
        cout << "nullptr" << endl;
    }

    void printListReverse() {
        Node* current = tail;
        cout << "List (backward): nullptr <-> ";
        while (current != nullptr) {
            cout << current->data << " <-> ";
            current = current->prev;
        }
        cout << "nullptr" << endl;
    }
};

int main() {
    DoublyLinkedList dll;
    
    dll.push_front(30);
    dll.push_front(20);
    dll.push_front(10);

    dll.printList();
    dll.printListReverse();

    return 0;
}
```

-----
