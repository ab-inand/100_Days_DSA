

#### \#\# Medium: Solve the "Valid Parentheses" Problem

This solution uses a `std::stack` to track the opening brackets. An `unordered_map` is also used for a clean way to check for matching pairs.

```cpp
#include <iostream>
#include <stack>
#include <string>
#include <unordered_map>

using namespace std;

bool isValidParentheses(const string& s) {
    stack<char> openBrackets;
    // Map closing brackets to their corresponding opening brackets for easy lookup
    unordered_map<char, char> mappings = {{')', '('}, {'}', '{'}, {']', '['}};

    for (char c : s) {
        // If it's a closing bracket
        if (mappings.count(c)) {
            // Check if stack is empty or if the top doesn't match
            if (openBrackets.empty() || openBrackets.top() != mappings[c]) {
                return false; // Invalid sequence
            }
            openBrackets.pop(); // Match found, pop the opening bracket
        } else {
            // It must be an opening bracket, so push it onto the stack
            openBrackets.push(c);
        }
    }

    // If the stack is empty at the end, all brackets were matched correctly
    return openBrackets.empty();
}

int main() {
    string s1 = "()[]{}";
    string s2 = "([)]";
    string s3 = "{[]}";
    
    cout << "'" << s1 << "' is valid: " << (isValidParentheses(s1) ? "true" : "false") << endl;
    cout << "'" << s2 << "' is valid: " << (isValidParentheses(s2) ? "true" : "false") << endl;
    cout << "'" << s3 << "' is valid: " << (isValidParentheses(s3) ? "true" : "false") << endl;

    return 0;
}
```

-----
